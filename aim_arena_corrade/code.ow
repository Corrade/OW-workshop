/*
Description ___________________________________________________________________

A different flavour of Beemoo's aim arena. Features an auto-reload + CD reset after each elimination, and takes place in Hanamura.    [v1.0 by Corrade]



Settings ______________________________________________________________________

Modes
    - Deathmatch
        - Spawn Health Packs: Disabled
Maps
    - Deathmatch
        - Hanamura

Heroes
    - Disabled
        - Bastion
        - Brigitte
        - D.Va
        - Moira
        - Orisa
        - Reinhardt
        - Roadhog
        - Winston
        - Wrecking Ball
        - Zarya
    - General
        - Ultimate Ability: Off
    - Baptiste
        - Immortality Field: Off
    - Symmetra
        - Sentry Turret: Off
    - Torbjorn
        - Deploy Turret: Off



Variables _____________________________________________________________________

gA = Time limit.
gB = Allowed heroes.
gC = Space of the arena as described by a parallelogram.
          A   B
        D   C
    The Y components of A, B and D are irrelevant.
    [0] = A vector.
    [1] = B vector.
    [2] = D vector.
    [3] = Ceiling height.
    [4] = Floor height.
    [5] = Point for respawning players to be set facing towards.
gD = Array of vectors: spawns must be in LOS of at least one of these points.
gE = Toggle for refreshing the DPS rank UI.
gF = Interval for refreshing the DPS rank UI.

pB = Number of seconds spent in-game.
pC = Most recent hero of player.
pD = Total damage of player on their current hero.
pE = Proposed spawn for smart respawn. Resting value = 0. Also a checkpoint in smart respawn.
pK = Parameter list for teleport module. If an argument is 999, the module applies special values.
    [0] = Trigger = 999. Resting value = 0. Also a checkpoint in teleport module.
    [1] = Teleport destination.
    [2] = Exit facing direction.
    [3] = Exit velocity.
pM = Triggers refresh if 999. Resting value = 0. Also a checkpoint in refresh.
pN = Whether or not the player variables have finished initialising.
*/



// Housekeeping _______________________________________________________________

disabled rule("Housekeeping") {event {Ongoing - Global;}}

rule("[Change me!] Set time limit (seconds)")
{
    event
    {
        Ongoing - Global;
    }

    actions
    {
        Set Global Variable(A, 1800);
    }
}

rule("Init global vars")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Player Variable(Event Player, B) == Null;
    }

    actions
    {
        Set Global Variable(C, Empty Array);
            /*
                Ilios Ruins
                Modify Global Variable(C, Append To Array, Vector(-29, 101, -107));
                Modify Global Variable(C, Append To Array, Vector(61, 107, -109));
                Modify Global Variable(C, Append To Array, Vector(-30, 101, -98));
                Modify Global Variable(C, Append To Array, 150);
                Modify Global Variable(C, Append To Array, 90);
                Modify Global Variable(C, Append To Array, Vector(28.5, 106, -105));
            */
            Modify Global Variable(C, Append To Array, Vector(94, 0, 42));
            Modify Global Variable(C, Append To Array, Vector(97, 0, 79));
            Modify Global Variable(C, Append To Array, Vector(36, 0, 59));
            Modify Global Variable(C, Append To Array, 3);
            Modify Global Variable(C, Append To Array, -3);
            Modify Global Variable(C, Append To Array, Vector(66, -1, 64));
        Set Global Variable(D, Empty Array);
            Modify Global Variable(D, Append To Array, Vector(70, -2.5, 74));
        Set Global Variable(F, 6);
    }
}

rule("Init gB")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    actions
    {
        Set Global Variable(B, Allowed Heroes(Event Player));
    }
}

rule("Skip assembly")
{
    event
    {
        Ongoing - Global;
    }

    conditions
    {
        Is Assembling Heroes == True;
    }

    actions
    {
        Set Match Time(0);
    }
}

rule("Apply game settings")
{
    event
    {
        Ongoing - Global;
    }

    conditions
    {
        Is Game In Progress == True;
    }

    actions
    {
        Disable Built-In Game Mode Scoring;
        Set Match Time(Global Variable(A));
    }
}



// Core _______________________________________________________________________

disabled rule("Core") {event {Ongoing - Global;}}

rule("Scoring")
{
    event
    {
        Player Died;
        All;
        All;
    }
    
    actions
    {
        Skip If(Compare(Victim, ==, Attacker), 1);
        Modify Player Score(Attacker, 1);
        Skip If(Compare(Victim, !=, Attacker), 1);
        Modify Player Score(Victim, -1);
    }
}

// Display the remaining health of the opponent after being eliminated.
rule("Health check")
{
    event
    {
        Player Died;
        All;
        All;
    }

    conditions
    {
        Entity Exists(Attacker) == True;
    }

    actions
    {
        Small Message(
            Event Player,
            String(
                "{0} {1} {2}",
                Health(Attacker),
                String("Remaining", Null, Null, Null),
                String(
                    "({0})",
                    String(
                        "{0}%",
                        Multiply(Normalized Health(Attacker), 100),
                        Null,
                        Null
                    ),
                    Null,
                    Null
                )
            )
        );
    }
}

rule("Instant respawn")
{
    event
    {
        Player Died;
        All;
        All;
    }

    actions
    {
        Respawn(Event Player);
    }
}

// Respawns the player in a random position in the arena.
// Pt1: generates an appropriate spawn and then prepares a call to
// teleport module.
rule("Smart respawn pt1")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Has Spawned(Event Player) == True;
        Is Alive(Event Player) == True;
    }

    actions
    {
        // Loop: generate spawn.
            // A random point in the arena parallelogram disregarding height.
            // See notes on gC.
            Set Player Variable(
                Event Player,
                E,
                Add(
                    Value In Array(Global Variable(C), 0),
                    Add(
                        Multiply(
                            Random Real(0, 1),
                            Vector Towards(
                                Value In Array(Global Variable(C), 0),
                                Value In Array(Global Variable(C), 1)
                            )
                        ),
                        Multiply(
                            Random Real(0, 1),
                            Vector Towards(
                                Value In Array(Global Variable(C), 0),
                                Value In Array(Global Variable(C), 2)
                            )
                        )
                    )
                )
            );
            // The point on the floor directly beneath the previous point.
            Set Player Variable(
                Event Player,
                E,
                Ray Cast Hit Position(
                    Vector(
                        X Component Of(Player Variable(Event Player, E)),
                        Subtract(Value In Array(Global Variable(C), 3), 1),
                        Z Component Of(Player Variable(Event Player, E))
                    ),
                    Vector(
                        X Component Of(Player Variable(Event Player, E)),
                        Subtract(Value In Array(Global Variable(C), 4), 1),
                        Z Component Of(Player Variable(Event Player, E))
                    ),
                    Null,
                    Null,
                    False
                )
            );
            Wait(0.016, Restart When True);
        // Loop if the raycast failed or if the point does not have LOS
        // with any point in gD.
        Loop If(
            Or(
                Compare(Player Variable(Event Player, E), ==, Value In Array(Global Variable(C), 4)),
                Not(Filtered Array(
                    Global Variable(D),
                    Is In Line Of Sight(
                        Current Array Element,
                        Add(Player Variable(Event Player, E), Vector(0, 1, 0)),
                        Barriers Do Not Block LOS
                    )
                ))
            )
        );
        // anubis, volskaya

        Set Player Variable At Index(Event Player, K, 1, Player Variable(Event Player, E));
        Set Player Variable At Index(Event Player, K, 2, Value In Array(Global Variable(C), 5));
        Set Player Variable At Index(Event Player, K, 3, 0);
        Set Player Variable(Event Player, E, 1);
    }
}

// Pt2: activates teleport module as soon as it's free.
rule("Smart respawn pt2")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Player Variable(Event Player, E) == 1;
        Value In Array(Player Variable(Event Player, K), 0) == 0;
    }

    actions
    {
        Set Player Variable At Index(Event Player, K, 0, 999);
        Set Player Variable(Event Player, E, 0);
    }
}

// Respawns the player in place in order to reset cooldowns, cleanse, etc.
// Pt1: handles exit cases. 
rule("Refresh pt1")
{
    event
    {
        Player Dealt Final Blow;
        All;
        All;
    }

    actions
    {
        Set Player Variable(Event Player, M, 1);
    }
}

// Pt2: respawns the player and activates teleport module as soon as it's free.
rule("Refresh pt2")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Player Variable(Event Player, M) == 1;
        Value In Array(Player Variable(Event Player, K), 0) == 0;
    }

    actions
    {
        Set Player Variable At Index(Event Player, K, 1, Position Of(Event Player));
        Set Player Variable At Index(Event Player, K, 2, Facing Direction Of(Event Player));
        Set Player Variable At Index(Event Player, K, 3, Velocity Of(Event Player));
        Respawn(Event Player);
        Set Player Variable At Index(Event Player, K, 0, 999);

        Set Player Variable(Event Player, M, 0);
    }
}

rule("Hero select")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Button Held(Event Player, Ultimate) == True;
        Is Alive(Event Player) == True;
    }

    actions
    {
        Skip If(
            Compare(Normalized Health(Event Player), ==, 1),
            1
        );
        Modify Player Score(Event Player, -1);

        // Taken from the original aim arena (Beemoo).
        Set Player Allowed Heroes(Event Player, Remove From Array(Global Variable(B), Hero Of(Event Player)));
        Wait(0.25, Ignore Condition);
        Set Player Allowed Heroes(Event Player, Global Variable(B));
    }
}

rule("Count damage")
{
    event
    {
        Player Dealt Damage;
        All;
        All;
    }
    
    conditions
    {
        Is Game In Progress == True;
    }

    actions
    {
        Abort If(Compare(Victim, ==, Event Player));
        Modify Player Variable(Event Player, D, Add, Event Damage);
    }
}

// Counts the number of seconds that the player has spent in-game.
rule("Count seconds")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Game In Progress == True;
    }

    actions
    {
        // Loop: count seconds.
            Modify Player Variable(Event Player, B, Add, 1);
            Wait(1, Ignore Condition);
        Loop;
    }
}

// Resets the time and damage counts of a player on hero change.
rule("Reset counts")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Compare(Hero Of(Event Player), ==, Player Variable(Event Player, C)) == False;
        Hero Of(Event Player) == True;
    }

    actions
    {
        Set Player Variable(Event Player, C, Hero Of(Event Player));

        Set Player Variable(Event Player, B, 0);
        Set Player Variable(Event Player, D, 0);
    }
}

rule("Refresh DPS UI")
{
    event
    {
        Ongoing - Global;
    }

    actions
    {
        // Loop: refresh interval. Uses a fancy progress bar - only gF should
        // be changed.
            Set Global Variable(E, 7.49);
            Chase Global Variable Over Time(E, -0.5, Global Variable(F), None);
            Wait(Subtract(Global Variable(F), 0.1), Ignore Condition);
            
            Destroy All HUD Text;
            Create HUD Text(
                All Players(All Teams),
                Null,
                String(
                    "{0} {1}",
                    String("Loading", Null, Null, Null),
                    Round To Integer(Divide(Subtract(Raise To Power(10, Round To Integer(Add(Global Variable(E), 1), To Nearest)), 1), 9), To Nearest),
                    Null
                ),
                Null,
                Left,
                1,
                White,
                White,
                White,
                Visible To and String
            );

            Set Global Variable(E, -0.5);
            Wait(0.016, Ignore Condition);
        Loop;
    }
}

rule("Generate DPS UI")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Global Variable(E) == -0.5;
    }

    actions
    {
        Create HUD Text(
            All Players(All Teams),
            Null,
            Null,
            String(
                "{0}: {1}",
                String(
                    "{0} {1}",
                    Hero Icon String(Hero Of(Event Player)),
                    Event Player,
                    Null
                ),
                Divide(Player Variable(Event Player, D), Player Variable(Event Player, B)),
                Null
            ),
            Left,
            Multiply(
                Divide(Player Variable(Event Player, D), Player Variable(Event Player, B)),
                -1
            ),
            White,
            White,
            White,
            Visible To and String
        );
    }
}



// Modules ____________________________________________________________________

disabled rule("Modules") {event {Ongoing - Global;}}

// This rule sequence is needed because teleporting and set facing have
// strange delays/requirements that must be waited for.
// Pt1: cancels motion.
rule("Teleport module pt1")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Value In Array(Player Variable(Event Player, K), 0) == 999;
    }

    actions
    {
        Apply Impulse(
            Event Player, Multiply(-1.000, Velocity Of(Event Player)), Square Root(Dot Product(Velocity Of(Event Player), Velocity Of(Event Player))), To World, Incorporate Contrary Motion
        );
        Set Gravity(Event Player, Absolute Value(0));
        Set Move Speed(Event Player, Absolute Value(0));

        Set Player Variable At Index(Event Player, K, 0, 1);
    }
}

// Pt2: ensures teleportation works.
rule("Teleport module pt2")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        // Executes once the player is not at their teleport position. If the
        // teleport destination is at the player's position before the module
        // call, this is equivalent to waiting for the respawn to trigger.
        Value In Array(Player Variable(Event Player, K), 0) == 1;
        Compare(Distance Between(Position Of(Event Player), Value In Array(Player Variable(Event Player, K), 1)), >, 1) == True;
    }

    actions
    {
        // Loop: teleport until it works, i.e. until the player is roughly at
        // the teleport position. This will ensure the teleport works in cases
        // where the destination is not at the player's position.
            Teleport(Event Player, Value In Array(Player Variable(Event Player, K), 1));
            Wait(0.016, Ignore Condition);
        Loop If Condition Is True;

        // Fork execution based on whether or not pK[2] is specified.
        Skip If(Compare(Value In Array(Player Variable(Event Player, K), 2), !=, 999), 2);
            Set Player Variable At Index(Event Player, K, 0, 3);
            Abort();
        Set Player Variable At Index(Event Player, K, 0, 2);
    }
}

// Pt3: ensures set facing works, applies the exit velocity and restores
// motion.
rule("Teleport module pt3")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Or(
            Compare(Value In Array(Player Variable(Event Player, K), 0), ==, 2),
            Compare(Value In Array(Player Variable(Event Player, K), 0), ==, 3)
        ) == True;
    }

    actions
    {
        // Loop: set facing direction until it works, i.e. until the player
        // is roughly facing in the set direction.
            // If pK[2] was unspecified, constantly update it to the vector
            // from the player to their opponent.
            Skip If(Compare(Value In Array(Player Variable(Event Player, K), 0), !=, 3), 1);
                Set Player Variable At Index(
                    Event Player, K, 2, Subtract(Position Of(Value In Array(Player Variable(Event Player, F), 0)), Position Of(Event Player))
                );
            Set Facing(Event Player, Value In Array(Player Variable(Event Player, K), 2), To World);
            Wait(0.016, Ignore Condition);
        Loop If(Compare(Absolute Value(Subtract(1, Dot Product(Facing Direction Of(Event Player), Normalize(Value In Array(Player Variable(Event Player, K), 2))))), >, 0.050));

        Set Move Speed(Event Player, 100);
        Set Gravity(Event Player, 100);
        Apply Impulse(
            Event Player, Value In Array(Player Variable(Event Player, K), 3), Square Root(Dot Product(Value In Array(Player Variable(Event Player, K), 3), Value In Array(Player Variable(Event Player, K), 3))), To World, Incorporate Contrary Motion
        );
        
        Set Player Variable At Index(Event Player, K, 0, 0);
    }
}



// Testing ____________________________________________________________________

disabled rule("Testing") {event {Ongoing - Global;}}

disabled rule("Testing: display server performance")
{
    event
    {
        Ongoing - Global;
    }

    actions
    {
        Create HUD Text(
            All Players(All Teams),
            String("{0}: {1}", String("Server Load", Null, Null, Null), String("{0}%", Server Load, Null, Null), Null),
            Null,
            Null,
            Left,
            0,
            White,
            White,
            White,
            Visible To and String
        );
        Create HUD Text(
            All Players(All Teams),
            String("{0}: {1}", String("Server Load Average", Null, Null, Null), String("{0}%", Server Load Average, Null, Null), Null),
            Null,
            Null,
            Left,
            0,
            White,
            White,
            White,
            Visible To and String
        );
        Create HUD Text(
            All Players(All Teams),
            String("{0}: {1}", String("Server Load Peak", Null, Null, Null), String("{0}%", Server Load Peak, Null, Null), Null),
            Null,
            Null,
            Left,
            0,
            White,
            White,
            White,
            Visible To and String
        );
    }
}

// Ability 1.
disabled rule("Testing: increment score")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Button Held(Event Player, Ability 1) == True;
    }

    actions
    {
        Modify Player Score(Event Player, 1);
    }
}

// Primary + secondary fire.
disabled rule("Testing: win round")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Button Held(Event Player, Primary Fire) == True;
        Is Button Held(Event Player, Secondary Fire) == True;
    }

    actions
    {
        Set Player Variable(Event Player, D, 2);
        Set Player Variable(Value In Array(Player Variable(Event Player, F), 0), D, 1);
    }
}

// Secondary fire.
disabled rule("Testing: activate refresh")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Button Held(Event Player, Secondary Fire) == True;
        Has Spawned(Event Player) == True;
        Is Alive(Event Player) == True;
    }

    actions
    {
        Set Player Variable(Event Player, M, 999);
    }
}

// Any communication.
disabled rule("Testing: killbind")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Communicating Any(Event Player) == True;
    }

    actions
    {
        Kill(Event Player, Null);
    }
}

disabled rule("Testing: reveal all players")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    actions
    {
        Create Icon(All Players(All Teams), Event Player, Arrow: Down, Visible To and Position, Green, True);
    }
}

disabled rule("Testing: show position")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    actions
    {
        Create HUD Text(All Players(All Teams), Position Of(Event Player), Null, Null, Left, 0, White, White, White, Visible To and String);
    }
}

// Ability 1.
disabled rule("Testing: toggle gravity")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Button Held(Event Player, Ability 1) == True;
    }

    actions
    {
        Set Gravity(Event Player, Global Variable(Z));
        Set Global Variable(Z, Subtract(100, Global Variable(Z)));
    }
}

// Primary fire.
disabled rule("Testing: teleport forwards")
{
    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Is Button Held(Event Player, Primary Fire) == True;
    }

    actions
    {
        Teleport(Event Player, Add(Position Of(Event Player), Multiply(Facing Direction Of(Event Player), 15)));
        Wait(0.1, Ignore Condition);
        Loop If Condition Is True;
    }
}