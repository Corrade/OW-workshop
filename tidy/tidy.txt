<!DOCTYPE html>
<html>

<head>
    <style type = text/css>
        body {
            font-family: Arial, Helvetica, sans-serif;
            background-color: WhiteSmoke;
            max-width: 600px;
        }
        .cont_hor {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 400px;
        }
        input[type=checkbox] {
              zoom: 2;
        }
        button {
            height: 50px;
            width: 200px;
        }
    </style>
</head>

<body>
    This script takes in workshop code generated by the editor and tidies it up by expanding
    long actions/conditions/values and adding some white space.
    <br/><br/>
    
    <h3>Input</h3>
    <textarea id="input_area" rows="10" cols="100"/></textarea>
    <br/><br/>
    
    <h3>Options</h3>
    <div class="cont_hor">
        <label>Expand threshold*:</label>
        <input id="expand_in" type="text">
    </div>
    <div class="cont_hor">
        <label>Tab size**:</label>
        <input id="tab_size_in" type="text">
    </div>
    <div class="cont_hor">
        <label>Replace tabs with spaces:</label>
        <input id="replace_tabs_in" type="checkbox">
    </div>
    <br/><br/>
    
    <i>
    *The maximum amount of characters that a line can be before the script tries to
    expand it.
    <br/><br/>
    **Besides specifying how many spaces to replace each tab with if you choose
    that option, tab size is also used to calculate line length, which can affect
    line expansion. So it does matter if you set it to a weird value!
    </i>
    <br/><br/>
    
    <h3>Output</h3>
    <textarea id="output_area" rows="10" cols="100" disabled/></textarea>
    <br/><br/>
    <button id="copy_but" onclick="copy()">Copy to Clipboard</button>
    <br/><br/>
</body>

</html>



<script>

const expand_default = 80;
const tab_size_default = 4;

const input_area = document.getElementById("input_area");
input_area.addEventListener("input", function() { main(); });

const expand_in = document.getElementById("expand_in");
expand_in.value = expand_default;
expand_in.save = expand_in.value;
expand_in.addEventListener("input", function() { check_input_numonly(event, this); main(); });
const tab_size_in = document.getElementById("tab_size_in");
tab_size_in.value = tab_size_default;
tab_size_in.save = tab_size_in.value;
tab_size_in.addEventListener("input", function() { check_input_numonly(event, this); main(); });
const replace_tabs_in = document.getElementById("replace_tabs_in");
replace_tabs_in.checked = true;
replace_tabs_in.addEventListener("input", function() { main(); });

const output_area = document.getElementById("output_area");

const copy_but = document.getElementById("copy_but");



function check_input_numonly(event, ele)
{
    if (!is_num(ele.value, 0)) {
        ele.value = ele.save;
    } else {
        ele.save = ele.value;
    }
}

function copy()
{
    output_area.disabled = false;
    output_area.select();
    document.execCommand("copy");
    output_area.disabled = true;
    window.getSelection().removeAllRanges();
}

function main()
{
    let settings = "";
    let variables = "";
    let lines = input_area.value.split("\n");
    
    // Extract settings and variables
    for (let i = 0; i < lines.length; i++) {
        if (/^settings$/.test(lines[i])) {
            for (; i < lines.length; i++) {
                const line = lines[i];
                settings += lines[i] + "\n";
                lines[i] = "";
                
                if (/^\}$/.test(line)) {
                       break;
                   }
            }
        }
        
        if (/^variables$/.test(lines[i])) {
            for (; i < lines.length; i++) {
                const line = lines[i];
                variables += lines[i] + "\n";
                lines[i] = "";
                
                if (/^\}$/.test(line)) {
                       break;
                   }
            }
        }
    }
    
    remove_space_indentation(lines);
    lines = normalise_main(lines.join("\n"));
    insert_whitespace_main(lines);
    try_expand(lines);
    
    output_area.value = "";
    
    if (settings != "") {
        output_area.value += settings + "\n\n\n";
    }
    
    if (variables != "") {
        output_area.value += variables + "\n\n\n";
    }
    
    output_area.value += lines.join("\n") + "\n";
    
    if (replace_tabs_in.checked) {
        output_area.value = replace_tabs_spaces(output_area.value);
    }
}

// text: map code
// return: array of lines with correct newline placement, which involves giving every action its own line.
// Tab identation is also removed.
function normalise_main(text)
{
    let chars = text.split("");
    let inside_quotes = false;
    
    for (let i = 0; i < chars.length; i++) {
        if (chars[i] === "\\") {
            i++;
            continue;
        }
        
        if (chars[i] === '"') {
            // If this quote is closing a comment
            if (inside_quotes && !/[\),;]/.test(chars[i + 1])) {
                chars[i] += "\n";
            }
            
            inside_quotes = !inside_quotes;
            continue;
        }
        
        if (inside_quotes) {
            continue;
        }
        
        if (chars[i] === "\t" || chars[i] === "\n") {
            chars[i] = "";
        } else if (chars[i] === "," && chars[i + 1] != " ") {
            chars[i] = ", ";
        } else if (chars[i] === "{") {
            chars[i] = "\n{\n";
        } else if (chars[i] === "}") {
            chars[i] = "}\n";
        } else if (chars[i] === ";") {
            chars[i] = ";\n";
        }
    }
    
    return chars.join("").split("\n");
}

// lines: array generated by normalise_main()
function remove_space_indentation(lines)
{
    for (let i = 0; i < lines.length; i++) {
        lines[i] = lines[i].replace(/^ */, "");
    }
}

// lines: array generated by normalise_main()
// Function: applies tab indentation and adds newline whitespace
function insert_whitespace_main(lines)
{
    let indent = 0;
    
    for (let i = 0; i < lines.length; i++) {
    	let this_indent = 0;
        let pre_newlines = 0;
        let post_newlines = 0;
        
        if (first_char(lines[i]) === "}") {
            indent--;
            
            if (i + 1 < lines.length) {
                if (is_rule(lines[i + 1])) {
                    // Separate rules with three empty lines
                    post_newlines = 3;
                } else if (first_char(lines[i + 1]) != "}") {
                    // Separate event, condition and action segments with one empty line
                    post_newlines = 1;
                }
            }
        }
        
        if (/^End/.test(lines[i])) {
        	indent--;
        }
        
        this_indent += indent;
        
        if (/^If/.test(lines[i]) || /^While/.test(lines[i]) || /^For/.test(lines[i])) {
        	indent++;
        } else if (/^Else( If)?/.test(lines[i])) {
        	this_indent--;
        } else if (first_char(lines[i]) === "{") {
            indent++;
        } else if (first_char(lines[i]) === '"') {
            // Precede comments with an empty line unless the comment is for a leading action
            if ((i - 1 >= 0) && (last_char(lines[i - 1]) != "{")) {
                pre_newlines = 1;
            }
        }
        
        lines[i] = "\n".repeat(pre_newlines) + "\t".repeat(this_indent) + lines[i] + "\n".repeat(post_newlines);
    }
}

// lines: array after calling insert_whitespace_main()
// Function: tries to expand any lines that are too long
function try_expand(lines)
{
    for (let i = 0; i < lines.length; i++) {
        if (true_line_length(lines[i]) <= expand_in.value) {
            continue;
        }
        
        const c = last_char(lines[i]);
        
        if (c === "," || c === ";" || (c === ")" && !is_rule(lines[i]))) {
            lines[i] = expand_part(lines[i]);
        }
    }
}

function replace_tabs_spaces(text)
{
    let lines = text.split("\n")
    
    for (let i = 0; i < lines.length; i++) {
        let n_tabs;
        for (n_tabs = 0; (n_tabs < lines[i].length) && (lines[i].charAt(n_tabs) === "\t"); n_tabs++) {
            ;
        }
        
        lines[i] = lines[i].replace(new RegExp("^\t{" + n_tabs + "}"), " ".repeat(tab_size_in.value * n_tabs));
    }
    
    return lines.join("\n");
    
    // Cleaner solution, but not supported by many browsers due to the lookbehind assertion in the regex
    // text = text.replace(/(?<=\t*)\t/g, " ".repeat(tab_size_in.value));
}



// Parts _________________________________________________________________________

// line: one-line action, condition or value
// return: expanded copy or the original line if unsuccessful
function expand_part(line)
{
    let rule_lines = normalise_part(line);
    insert_whitespace_part(rule_lines, count_leading_tabs(line));
    
    if (line == rule_lines) {
        return line;
    }
    
    try_expand(rule_lines);
    
    return rule_lines.join("\n");
}

// line: one-line action, condition or value
// return: array with correct newline placement, which involves giving every value its own line. Tab identation
// is also removed.
function normalise_part(line)
{
    let chars = line.split("");
    let inside_quotes = false;
    let brackets = 0;
    
    for (let i = 0; i < chars.length; i++) {
        if (chars[i] === "\\") {
            i++;
            continue;
        }
        
        if (chars[i] === '"') {
            // If this quote is closing a comment
            if (inside_quotes && !/[\),;]/.test(chars[i + 1])) {
                chars[i] += "\n";
            }
            
            inside_quotes = !inside_quotes;
            continue;
        }
        
        if (inside_quotes) {
            continue;
        }
        
        if (chars[i] === "\t" || chars[i] === "\n") {
            chars[i] = "";
        } else if (chars[i] === "," && brackets === 1) {
            chars[i] = ",\n";
            if (i + 1 < chars.length && chars[i + 1] === " ") {
                chars[i + 1] = "";
            }
        } else if (chars[i] === "(") {
            if (brackets === 0) {
                chars[i] = "(\n";
            }
            brackets++;
        } else if (chars[i] === ")") {
            brackets--;
            if (brackets === 0) {
                chars[i] = "\n)";
            }
        }
    }
    
    return chars.join("").split("\n");
}

// lines: array generated by normalise_part()
// rule_n_leading_tabs: number of leading tabs that the first line of the rule or value should have
// Function: applies tab indentation
function insert_whitespace_part(lines, rule_n_leading_tabs)
{
    for (let i = 0; i < lines.length; i++) {
        if (i == 0 || i == lines.length - 1) {
            lines[i] = "\t".repeat(rule_n_leading_tabs) + lines[i];
        } else {
            lines[i] = "\t".repeat(rule_n_leading_tabs + 1) + lines[i];
        }
    }
}



// Auxiliary _____________________________________________________________________

function is_rule(line)
{
    return /^(disabled )?rule\(.*\)$/.test(line);
}

function true_line_length(line)
{
    return line.length - count_leading_tabs(line) + tab_size_in.value * count_leading_tabs(line);
}

function remove_leading_tabs(str)
{
    const res = str.match(/[^\t]*$/)[0];
    return (res === null) ? "" : res;
}

function count_leading_tabs(str)
{
    let i;
    for (i = 0; i < str.length && str.charAt(i) === "\t"; i++) {
        ;
    }
    
    return i;
}

function first_char(str)
{
    return str.charAt(0);
}

function last_char(str)
{
    return str.charAt(str.length - 1);
}

function is_num(x, float)
{
    return (float ? /^\d*\.?\d*$/ : /^\d*$/).test(String(x));
}

</script>